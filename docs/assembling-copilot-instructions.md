# Assembling Copilot Instructions

After building your knowledge library by [ingesting prompts from your projects](ingesting-prompts.md), Context Mixer's most powerful feature is its ability to intelligently assemble context-specific instructions for AI coding assistants. This guide shows you how to create tailored copilot-instructions files for your projects.

## Understanding Context Assembly

Context assembly is where the CRAFT framework really shines. Instead of manually copying and pasting context fragments, Context Mixer:

1. **Analyzes your project** to understand its domain, technology stack, and requirements
2. **Selects relevant knowledge** from your library based on the project context
3. **Resolves conflicts** between different approaches or patterns
4. **Optimizes for token limits** while maximizing relevance
5. **Assembles coherent instructions** tailored to your specific project

## Basic Assembly Workflow

### 1. Analyze Your Project

First, let Context Mixer understand your project:

```bash
cd /path/to/your/project
cmx analyze
```

This scans your project to identify:
- Technology stack (React, Python, Java, etc.)
- Project type (web app, API, mobile, etc.)
- Existing patterns and conventions
- Dependencies and frameworks

### 2. Assemble Instructions for GitHub Copilot

Generate a copilot-instructions file for your project:

```bash
cmx assemble --target copilot
```

This creates `.github/copilot-instructions.md` with context tailored to your project.

### 3. Assemble for Other AI Assistants

Context Mixer supports multiple AI assistant formats:

```bash
# For Cursor
cmx assemble --target cursor

# For Claude
cmx assemble --target claude

# For Junie
cmx assemble --target junie

# For multiple targets at once
cmx assemble --target copilot,cursor,claude
```

## Advanced Assembly Options

### Project-Specific Assembly

Provide additional context about your project:

```bash
# Specify project type and domain
cmx assemble --target copilot --project-type "e-commerce web app" --domain frontend

# Include specific technologies
cmx assemble --target copilot --tech react,typescript,tailwind,nextjs

# Specify team or organization context
cmx assemble --target copilot --team alpha --org enterprise
```

### Selective Knowledge Assembly

Choose which knowledge domains to include:

```bash
# Only include frontend patterns
cmx assemble --target copilot --domains frontend

# Include multiple domains
cmx assemble --target copilot --domains frontend,backend,testing

# Exclude certain domains
cmx assemble --target copilot --exclude legacy,experimental
```

### Authority-Based Assembly

Control the authority level of included knowledge:

```bash
# Only official, proven patterns
cmx assemble --target copilot --authority official

# Include experimental patterns for innovation projects
cmx assemble --target copilot --authority official,experimental

# Include deprecated patterns for legacy maintenance
cmx assemble --target copilot --authority official,deprecated
```

### Token Optimization

Optimize for different context limits:

```bash
# Optimize for GitHub Copilot's limits
cmx assemble --target copilot --max-tokens 8000

# Create a condensed version for smaller limits
cmx assemble --target copilot --max-tokens 4000 --priority high

# Create an extended version for larger contexts
cmx assemble --target copilot --max-tokens 16000 --include-examples
```

## Understanding Assembly Output

### Standard Assembly Structure

A typical assembled copilot-instructions file includes:

```markdown
# Project Context for AI Assistant

## Project Overview
[Generated project description based on analysis]

## Technology Stack
[Relevant technologies and frameworks]

## Development Patterns
[Coding patterns and conventions from your knowledge library]

## Architecture Guidelines
[Architectural decisions and patterns]

## Testing Approach
[Testing patterns and practices]

## Code Style and Standards
[Formatting, naming, and style guidelines]

## Common Patterns and Examples
[Specific code examples and patterns]

## Project-Specific Considerations
[Unique requirements or constraints]
```

### Metadata and Traceability

Each assembled file includes metadata for traceability:

```markdown
<!-- Generated by Context Mixer CRAFT system -->
<!-- Source chunks: 12 -->
<!-- Domains: frontend, testing, architecture -->
<!-- Authority: official, experimental -->
<!-- Generated: 2024-01-15T10:30:00Z -->
```

## Assembly Strategies

### For New Projects

When starting a new project, assemble comprehensive instructions:

```bash
# Create comprehensive instructions for a new React project
cmx assemble --target copilot \
  --project-type "new react web app" \
  --tech react,typescript,vite \
  --domains frontend,testing,deployment \
  --authority official \
  --include-examples
```

### For Existing Projects

When adding Context Mixer to existing projects, merge with current practices:

```bash
# Analyze existing project patterns first
cmx analyze --learn-from-project

# Then assemble, incorporating learned patterns
cmx assemble --target copilot --merge-existing --authority official,project-specific
```

### For Team Standardization

Create consistent instructions across team projects:

```bash
# Use team-specific knowledge and standards
cmx assemble --target copilot \
  --team backend-team \
  --domains backend,testing,deployment \
  --authority official \
  --template team-standard
```

### For Specialized Contexts

Tailor instructions for specific development contexts:

```bash
# For bug fixing and maintenance
cmx assemble --target copilot --context debugging --include-troubleshooting

# For performance optimization
cmx assemble --target copilot --context performance --domains optimization

# For security-focused development
cmx assemble --target copilot --context security --include-compliance
```

## Interactive Assembly

For complex projects, use interactive mode to fine-tune the assembly:

```bash
cmx assemble --target copilot --interactive
```

This allows you to:
- Review and approve each knowledge chunk
- Resolve conflicts between different approaches
- Customize the final output
- Add project-specific notes and exceptions

Example interactive session:
```
ü§ñ Context Mixer Interactive Assembly

üìã Project Analysis:
  Type: React TypeScript Web App
  Domains: frontend, testing
  Technologies: react, typescript, tailwind

üß† Knowledge Selection:
  ‚úì React functional component patterns (official)
  ‚úì TypeScript best practices (official)
  ‚ö†Ô∏è  Conflict: CSS approach
    Option 1: Tailwind utility classes (experimental)
    Option 2: CSS modules (official)
    Choose [1/2/both]: both

  ‚úì Testing with Jest and RTL (official)
  ? Include performance optimization patterns? [y/N]: y

üîß Token Optimization:
  Current size: 6,500 tokens
  Target: 8,000 tokens
  Space available: 1,500 tokens
  
  Add examples? [y/N]: y
  Add troubleshooting section? [y/N]: n

‚úÖ Assembly complete!
```

## Updating and Maintaining Instructions

### Regular Updates

Keep your instructions current as your knowledge library evolves:

```bash
# Update instructions with latest knowledge
cmx assemble --target copilot --update

# Check for outdated patterns
cmx validate-instructions .github/copilot-instructions.md

# Refresh with new knowledge from recent ingestions
cmx assemble --target copilot --refresh --since "1 week ago"
```

### Version Management

Track changes to your assembled instructions:

```bash
# Create versioned instructions
cmx assemble --target copilot --version v2.1

# Compare with previous version
cmx diff-instructions .github/copilot-instructions.md --version v2.0

# Rollback to previous version if needed
cmx assemble --target copilot --rollback v2.0
```

## Multi-Project Workflows

### Consistent Instructions Across Projects

Maintain consistency across multiple related projects:

```bash
# Create a template for similar projects
cmx create-template --name "react-web-app" --from ./flagship-project

# Apply template to new projects
cmx assemble --target copilot --template react-web-app

# Update all projects using a template
cmx batch-update --template react-web-app --projects ~/work/frontend-*
```

### Project-Specific Customizations

While maintaining consistency, allow for project-specific needs:

```bash
# Base instructions + project-specific additions
cmx assemble --target copilot \
  --base-template react-web-app \
  --add-context "This project uses GraphQL instead of REST" \
  --include-domain graphql
```

## Quality Assurance

### Validation and Testing

Ensure your assembled instructions are high quality:

```bash
# Validate instruction quality
cmx validate-instructions .github/copilot-instructions.md

# Test with sample prompts
cmx test-instructions .github/copilot-instructions.md --prompts test-scenarios.md

# Check for conflicts or contradictions
cmx check-consistency .github/copilot-instructions.md
```

### Feedback Integration

Improve your knowledge library based on real usage:

```bash
# Analyze how well instructions work in practice
cmx analyze-effectiveness .github/copilot-instructions.md --usage-data

# Update knowledge library based on feedback
cmx learn-from-usage --project ./current-project --update-library
```

## Best Practices

### 1. Start Simple, Iterate

Begin with basic assembly and refine over time:

```bash
# Initial assembly
cmx assemble --target copilot --authority official

# Add complexity as needed
cmx assemble --target copilot --authority official,experimental --include-examples
```

### 2. Maintain Consistency

Use consistent approaches across similar projects:

```bash
# Define project archetypes
cmx define-archetype "react-frontend" --domains frontend,testing --tech react,typescript

# Apply archetypes consistently
cmx assemble --target copilot --archetype react-frontend
```

### 3. Regular Maintenance

Keep instructions current and relevant:

```bash
# Monthly knowledge library updates
cmx update-library --validate --prune-outdated

# Quarterly instruction refresh
cmx batch-refresh --all-projects --validate
```

### 4. Team Collaboration

Share and standardize across your team:

```bash
# Export team standards
cmx export-standards --team backend --format template

# Import team member's improvements
cmx import-knowledge --from teammate-library --merge-strategy collaborative
```

## Troubleshooting

### Assembly Issues

**Problem**: Assembly produces irrelevant content
```bash
# Solution: Be more specific about project context
cmx assemble --target copilot --project-type "specific description" --exclude irrelevant-domain
```

**Problem**: Token limit exceeded
```bash
# Solution: Prioritize and optimize
cmx assemble --target copilot --max-tokens 8000 --priority high --exclude examples
```

**Problem**: Conflicting guidance
```bash
# Solution: Use interactive mode to resolve conflicts
cmx assemble --target copilot --interactive --resolve-conflicts
```

### Quality Issues

**Problem**: Instructions too generic
```bash
# Solution: Add more project-specific context
cmx assemble --target copilot --learn-from-project --include-project-patterns
```

**Problem**: Missing important patterns
```bash
# Solution: Check knowledge library coverage
cmx analyze-coverage --project ./current-project --suggest-missing
```

## Next Steps

With your copilot instructions assembled, you can:

1. **Test the instructions** with your AI assistant to ensure they work well
2. **Iterate and improve** based on real usage feedback
3. **Share with your team** to standardize practices
4. **Expand your knowledge library** by ingesting more projects
5. **Automate the process** with CI/CD integration for consistent updates

The goal is to create a living system where your context instructions continuously improve and adapt to your evolving development practices.